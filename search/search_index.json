{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cadwyn","text":"<p>Production-ready community-driven modern Stripe-like API versioning in FastAPI</p> <p> </p>"},{"location":"#who-is-this-for","title":"Who is this for?","text":"<p>Cadwyn allows you to support a single version of your code while auto-generating the schemas and routes for older versions. You keep API versioning encapsulated in small and independent \"version change\" modules while your business logic stays simple and knows nothing about versioning.</p> <p>Its approach will be useful if you want to:</p> <ol> <li>Support many API versions for a long time</li> <li>Effortlessly backport features and bugfixes to older API versions</li> </ol> <p>Whether you are a newbie in API versioning, a pro looking for a sophisticated tool, an experimenter looking to build a similar framework, or even someone who just wants to learn about all approaches to API versioning -- Cadwyn has the functionality, theory, and documentation to cover all the mentioned use cases.</p>"},{"location":"#get-started","title":"Get started","text":"<p>It is recommended to read the tutorial first to get your feet wet with Cadwyn's approach</p>"},{"location":"recipes/","title":"Recipes","text":"<p>This section serves as a guide to help you create new versions effectively and maintain your old versions with ease. It consists of a collection of scenarios for different types of breaking changes.</p> <p>To follow this guide, choose a type of an entity that you'd like to alter (an endpoint, a schema, etc), find the respective level two subheading, and follow its instructions. Repeat for every breaking change you would like to do.</p> <p>The guide will assume the following directory structure:</p> <pre><code>\u251c\u2500\u2500 routes.py\n\u251c\u2500\u2500 data\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 unversioned\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 users.py\n\u2502   \u2514\u2500\u2500 latest\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 users.py\n\u2514\u2500\u2500 versions\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 v2001_01_01.py\n</code></pre> <p>Schemas, enums, and any other versioned data are inside the <code>data.latest</code> package, version changes are inside the <code>versions.vXXXX_XX_XX</code> modules, and version bundle is inside the <code>versions.__init__</code> module. It includes all versions with all version changes -- including the ones you add in the recipes.</p> <p>You can assume that we already have a version 2000-01-01 and we are making a new version 2001-01-01 with the changes from our scenarios.</p> <p>Versioning is a complex topic with more pitfalls than you'd expect so please: do not try to skip this guide. Otherwise, your code will quickly get unmaintainable. Please also note that any of these scenarios can be combined in any way even within a single version change, though it's recommended to keep the version changes atomic as described in methodology section.</p>"},{"location":"recipes/#methodology","title":"Methodology","text":"<p>Cadwyn implements a methodology that is based on the following set of principles:</p> <ul> <li>Each version is made up of \"version changes\" or \"compatibility gates\" which describe independent atomic differences between it and previous version</li> <li>We make a new version if an only if we have breaking changes</li> <li>Versions must have little to no effect on the business logic</li> <li>Versions must always be compatible in terms of data</li> <li>Creating new versions is avoided at all costs</li> <li>Any backwards compatible features must be backported to all compatible versions</li> </ul> <p>These rules give us an ability to have a large number of self-documenting versions while encapsulating their complexity in small version change classes, providing a consistent and stable experience to our users.</p> <p>So if we see that we need to make a breaking change, our general approach is to:</p> <ol> <li>Make the breaking change in your schemas, routes, or business logic</li> <li>Write a version change class (and sometimes a little extra) that describes the difference between the new version and the old version</li> </ol>"},{"location":"recipes/#a-note-on-data-versioning","title":"A note on data versioning","text":"<p>Oftentimes you will want to introduce a breaking change where one of the following is true:</p> <ul> <li>Old data cannot be automatically converted to the structure of the new response</li> <li>New response cannot be automatically migrated to an older response</li> <li>Old request cannot be automatically converted to the latest or internal request</li> </ul> <p>This means that you are not versioning your API, you are versioning your data. This is not and cannot be solved by an API versioning framework. It also makes it incredibly hard to version as you now cannot guarantee compatibility between versions. Avoid this at all costs -- all your API versions must be compatible between each other.</p>"},{"location":"recipes/#schemas-openapi-data-type","title":"Schemas (openapi data type)","text":""},{"location":"recipes/#requests-and-responses","title":"Requests and Responses","text":"<p>In this section, we will cover situations where both requests and respones are affected. We'll be working with our user's response and request models: <code>UserResource</code> and <code>UserCreateRequest</code>. Both of them are located in <code>data.latest.users</code> and both of them share a parent class: <code>User</code> that contains the fields shared by both requests and responses.</p>"},{"location":"recipes/#schema-field-renaming","title":"Schema field renaming","text":"<p>Let's say that we had a \"summary\" field before but now we want to rename it to \"bio\".</p> <ol> <li>Rename <code>summary</code> field to <code>bio</code> in <code>data.latest.users.User</code></li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code>:</p> <pre><code>from cadwyn.structure import (\n    VersionChange,\n    schema,\n    convert_response_to_previous_version_for,\n    convert_request_to_next_version_for,\n    ResponseInfo,\n    RequestInfo,\n)\nfrom data.latest.users import User, UserCreateRequest, UserResource\n\n\nclass RenameSummaryIntoBioInUser(VersionChange):\n    description = \"Rename 'summary' field into 'bio' to keep up with industry standards\"\n    instructions_to_migrate_to_previous_version = (\n        schema(User).field(\"bio\").had(name=\"summary\"),\n    )\n\n    @convert_request_to_next_version_for(UserCreateRequest)\n    def rename_bio_to_summary(request: RequestInfo):\n        request.body[\"summary\"] = request.body.pop(\"bio\")\n\n    @convert_response_to_previous_version_for(UserResource)\n    def rename_bio_to_summary(response: ResponseInfo):\n        response.body[\"bio\"] = response.body.pop(\"summary\")\n</code></pre> </li> <li> <p>Regenerate the versioned schemas</p> </li> </ol>"},{"location":"recipes/#addition-or-narrowing-of-constraints","title":"Addition or Narrowing of constraints","text":"<p>Let's say that we previously allowed users to have a name of arbitrary length but now we want to limit it to 250 characters because we are worried that some users will be using inadequate lengths. You can't do this easily: if you simply add a <code>max_length</code> constraint to <code>User.name</code> -- the existing data in your database might become incompatible with this field in <code>UserResource</code>. So as long as incompatible data is there or can get there from some version -- you cannot add such a constraint to your responses. However, you can add it to your requests to prevent the creation of new user accounts with long names.</p> <ol> <li>Change <code>max_length</code> of <code>data.latest.users.UserResource.name</code> to 250</li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code>:</p> <pre><code>from cadwyn.structure import VersionChange, schema\nfrom data.latest.users import UserCreateRequest\n\n# Note that in pydantic v2 this would be `from pydantic_core import PydanticUndefined`\nfrom pydantic.fields import Undefined\n\n\nclass AddMaxLengthConstraintToUserNames(VersionChange):\n    description = (\n        \"Add a max length of 250 to user names when creating new users \"\n        \"to prevent overly large names from being used.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(UserCreateRequest).field(\"name\").had(max_length=Undefined),\n    )\n</code></pre> </li> <li> <p>Regenerate the versioned schemas</p> </li> </ol> <p>Note, however, that users will still be able to use arbitrary length names in older API versions. If you want to prevent that, then the correct approach would instead be the following:</p> <ol> <li>Check whether any users have names longer than 250 characters. If there are few or no users that have such long names, then it may make sense to skip step 1. The other steps, however, cannot be skipped if you want to guarantee that your API gives no 500s at any point in the process.</li> <li>Issue a 3-6 month warning to all users stating that you will make a breaking change affecting older versions. Mention that you will truncate old names that are longer than 250 characters and that users will no longer be able to create such long names even in old API versions.</li> <li>After the deadline, add a <code>max_length</code> constraint to <code>data.latest.users.UserCreateRequest.name</code></li> <li>Regenerate the versioned schemas</li> <li>Release it to production</li> <li>Truncate all names that are too long in the database (preferably using a migration and a separate release)</li> <li>Remove the <code>max_length</code> constraint from <code>data.latest.users.UserCreateRequest.name</code></li> <li>Add the <code>max_length</code> constraint to <code>data.latest.users.User.name</code></li> <li>Regenerate the versioned schemas</li> </ol> <p>This process seems quite complex but it's not Cadwyn-specific: if you want to safely and nicely version for your users, you will have to follow such a process even if you don't use any versioning framework at all.</p>"},{"location":"recipes/#removal-or-expansion-of-constraints","title":"Removal or Expansion of constraints","text":"<p>Let's say that we previously only allowed users to have a name of length 50 but now we want to allow names of length 250 too. It does not make sense to add this to a new API version. Just add it into all API versions because it is not a breaking change.</p> <p>The recommended approach:</p> <ol> <li>Change <code>max_length</code> of <code>data.latest.users.User.name</code> to 250</li> <li>Regenerate the versioned schemas</li> </ol> <p>However, sometimes it can be considered a breaking change if a large portion of your users use your system to verify their data and rely on your system to return status code <code>422</code> if this field is invalid. If that's the case, use the same approach as in constraint addition but use <code>50</code> instead of <code>pydantic.fields.Undefined</code> for the old value.</p>"},{"location":"recipes/#schema-field-removal","title":"Schema field removal","text":""},{"location":"recipes/#schema-optional-field-removal","title":"Schema optional field removal","text":"<p>Let's say that we had a nullable <code>middle_name</code> field but we decided that it does not make sense anymore and want to remove it now from both requests and responses. We can solve this with internal body request schemas.</p> <ol> <li>Remove <code>middle_name</code> field from <code>data.latest.users.User</code></li> <li> <p>Add a <code>data.unversioned.users.UserInternalCreateRequest</code> that we will use later to wrap migrated data instead of the latest request schema.</p> <pre><code>from pydantic import Field\nfrom ..latest.users import UserCreateRequest\n\n\nclass UserInternalCreateRequest(UserCreateRequest):\n    middle_name: str | None = Field(default=None)\n</code></pre> </li> <li> <p>Replace <code>UserCreateRequest</code> in your routes with <code>Annotated[UserInternalCreateRequest, InternalRepresentationOf[UserCreateRequest]]</code>:</p> <pre><code>from data.latest.users import UserCreateRequest, UserResource\nfrom cadwyn import InternalRepresentationOf\nfrom typing import Annotated\n\n\n@router.post(\"/users\", response_model=UserResource)\nasync def create_user(\n    user: Annotated[\n        InternalUserCreateRequest, InternalRepresentationOf[UserCreateRequest]\n    ]\n):\n    ...\n</code></pre> </li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code>:</p> <pre><code>from cadwyn.structure import (\n    VersionChange,\n    schema,\n    RequestInfo,\n)\nfrom data.latest.users import User\n\n\nclass RemoveMiddleNameFromUser(VersionChange):\n    description = \"Remove 'User.middle_name' field.\"\n    instructions_to_migrate_to_previous_version = (\n        schema(User)\n        .field(\"middle_name\")\n        .existed_as(type=str | None, description=\"User's Middle Name\", default=None),\n    )\n</code></pre> </li> <li> <p>Regenerate the versioned schemas</p> </li> </ol> <p>Note that in order for this to work, you would still have to store <code>middle_name</code> in your database and return it with your responses.</p> <p>Thus we have added a new API version and our business logic hasn't even noticed it.</p>"},{"location":"recipes/#schema-required-field-removal","title":"Schema required field removal","text":"<p>There are two main cases with required fields:</p> <ol> <li>Remove a required field with a simple fake default (created_at)</li> <li>Remove a required field with an impossible default (tax id)</li> </ol> <p>The first one is simple to solve: just use the approach above but use a <code>default_factory=datetime.datetime.now</code> instead of <code>default=None</code> within <code>UserInternalCreateRequest</code>.</p> <p>Now what about case 2?</p> <p>Let's say that you have company resources in your system. Let's also say that each company has a <code>tax_id</code> and now you would like to remove the <code>tax_id</code> field or make it optional. If <code>tax_id</code> was required in your responses, you can't really do this with traditional API versioning because you cannot come up with a sane non-null default for <code>tax_id</code>. It is a case of data versioning where you try to make an API version that is inconsistent with other API versions in terms of its data. You deal with this using one of the following approaches:</p> <ol> <li>Issue a warning to your users that <code>tax_id</code> is going to become optional in all API versions in <code>N</code> months and then make it so. This will allow you to avoid data versioning and your users will have a grace period to fix their issues. Then you can simply follow the approach above.</li> <li>Release a <code>V2</code> version of your API which users will have to migrate their data to. This is a drastic approach and you should only reserve it for extreme cases but it is a correct way to represent data versioning.</li> <li>Disallow the new version (2001-01-01) to be used alongside older versions and disallow users to migrate to older versions after they have migrated to 2001-01-01. Then you can simply follow the approach above. This is a dirty hack and an inconvenience to your users but it solves the problem too.</li> </ol>"},{"location":"recipes/#schema-field-addition","title":"Schema field addition","text":""},{"location":"recipes/#schema-optional-field-addition","title":"Schema optional field addition","text":"<p>Let's say we want our users to be able to specify a middle name but it is nullable. It is not a breaking change so no new version is necessary whether it is requests or responses.</p> <p>The recommended approach:</p> <ol> <li>Add a nullable <code>middle_name</code> field into <code>data.latest.users.User</code></li> <li>Regenerate the versioned schemas</li> </ol>"},{"location":"recipes/#schema-required-field-addition","title":"Schema required field addition","text":""},{"location":"recipes/#with-compatible-default-value-in-older-versions","title":"With compatible default value in older versions","text":"<p>Let's say that our users had a field <code>country</code> that defaulted to <code>USA</code> but our product is now used well beyond United States so we want to make this field required in the <code>latest</code> version.</p> <ol> <li>Remove <code>default=\"US\"</code> from <code>data.latest.users.UserCreateRequest</code></li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code>:</p> <pre><code>from cadwyn.structure import (\n    VersionChange,\n    schema,\n    convert_request_to_next_version_for,\n)\nfrom data.latest.users import UserCreateRequest, UserResource\n\n\nclass MakeUserCountryRequired(VersionChange):\n    description = 'Make user country required instead of the \"USA\" default'\n    instructions_to_migrate_to_previous_version = (\n        schema(UserCreateRequest).field(\"country\").had(default=\"USA\"),\n    )\n\n    @convert_request_to_next_version_for(UserCreateRequest)\n    def add_time_field_to_request(request: RequestInfo):\n        request.body[\"country\"] = request.body.get(\"country\", \"USA\")\n</code></pre> </li> <li> <p>Regenerate the versioned schemas</p> </li> </ol> <p>That's it! Our old schemas will now contain a default but in <code>latest</code> country will be required. You might notice a weirdness: if we set a default in the old version, why would we also write a migration? That's because of a sad implementation detail of pydantic that prevents us from using defaults from old versions.</p>"},{"location":"recipes/#with-incompatible-default-value-in-older-versions","title":"With incompatible default value in older versions","text":"<p>Let's say that we want to add a required field <code>phone</code> to our users. However, older versions did not have such a field at all. This means that the field is going to be nullable in the old versions but required in the latest version. This also means that older versions contain a wider type (<code>str | None</code>) than the latest version (<code>str</code>). So when we try to migrate request bodies from the older versions to latest -- we might receive a <code>ValidationError</code> because <code>None</code> is not an acceptable value for <code>phone</code> field in the new version. Whenever we have a problem like this, when older version contains more data or a wider type set of data,  we use internal body request schemas.</p> <ol> <li>Add <code>phone</code> field of type <code>str</code> to <code>data.latest.users.UserCreateRequest</code></li> <li>Add <code>phone</code> field of type <code>str | None</code> with a <code>default=None</code> to <code>data.latest.users.UserResource</code> because all users created with older versions of our API won't have phone numbers.</li> <li> <p>Add a <code>data.unversioned.users.UserInternalCreateRequest</code> that we will use later to wrap migrated data instead of the latest request schema. It will allow us to pass a <code>None</code> to <code>phone</code> from older versions while also guaranteeing that it is non-nullable in our latest version.</p> <pre><code>from pydantic import Field\nfrom ..latest.users import UserCreateRequest\n\n\nclass UserInternalCreateRequest(UserCreateRequest):\n    phone: str | None = Field(default=None)\n</code></pre> </li> <li> <p>Replace <code>UserCreateRequest</code> in your routes with <code>Annotated[UserInternalCreateRequest, InternalRepresentationOf[UserCreateRequest]]</code>:</p> <pre><code>from data.latest.users import UserCreateRequest, UserResource\nfrom cadwyn import InternalRepresentationOf\nfrom typing import Annotated\n\n\n@router.post(\"/users\", response_model=UserResource)\nasync def create_user(\n    user: Annotated[\n        InternalUserCreateRequest, InternalRepresentationOf[UserCreateRequest]\n    ]\n):\n    ...\n</code></pre> </li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code>:</p> <pre><code>from cadwyn.structure import (\n    VersionChange,\n    schema,\n)\nfrom data.latest.users import UserCreateRequest, UserResource\n\n\nclass AddPhoneToUser(VersionChange):\n    description = (\n        \"Add a required phone field to User to allow us to do 2fa and to \"\n        \"make it possible to verify new user accounts using an sms.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(UserCreateRequest)\n        .field(\"phone\")\n        .had(\n            type=str | None,\n            default=None,\n        ),\n    )\n</code></pre> </li> <li> <p>Regenerate the versioned schemas</p> </li> </ol> <p>See how we didn't remove the <code>phone</code> field from old versions? Instead, we allowed a nullable <code>phone</code> field to be passed into both old <code>UserResource</code> and old <code>UserCreateRequest</code>. This gives our users new functionality without needing to update their API version! It is one of the best parts of Cadwyn's approach: our users can get years worth of updates without switching their API version and without their integration getting broken.</p>"},{"location":"recipes/#schema-field-type-change-or-narrowing","title":"Schema field type change or narrowing","text":""},{"location":"recipes/#compatible-narrowing","title":"Compatible narrowing","text":"<p>Let's say that previously users could specify their date of birth as a datetime instead of a date. We wish to rectify that. We can solve this with internal body request schemas.</p> <ol> <li>Continue storing <code>date_of_birth</code> as a datetime in your database to avoid breaking any old behavior</li> <li>Change the type of <code>date_of_birth</code> field to <code>datetime.date</code> in <code>data.latest.users.User</code></li> <li> <p>Add a <code>data.unversioned.users.UserInternalCreateRequest</code> that we will use later to wrap migrated data instead of the latest request schema. This schema will allow us to keep time information from older versions without allowing users in new versions to provide it. This allows us to guarantee that old requests function in the same manner as before while new requests have the narrowed types.</p> <pre><code>from pydantic import Field\nfrom ..latest.users import UserCreateRequest\nimport datetime\n\n\nclass UserInternalCreateRequest(UserCreateRequest):\n    time_of_birth: datetime.time = Field(default=datetime.time(0, 0, 0))\n</code></pre> </li> <li> <p>Replace <code>UserCreateRequest</code> in your routes with <code>Annotated[UserInternalCreateRequest, InternalRepresentationOf[UserCreateRequest]]</code>:</p> <pre><code>from data.latest.users import UserCreateRequest, UserResource\nfrom cadwyn import InternalRepresentationOf\nfrom typing import Annotated\n\n\n@router.post(\"/users\", response_model=UserResource)\nasync def create_user(\n    user: Annotated[\n        InternalUserCreateRequest, InternalRepresentationOf[UserCreateRequest]\n    ]\n):\n    ...\n</code></pre> </li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code>:</p> <pre><code>from cadwyn.structure import (\n    VersionChange,\n    schema,\n    convert_request_to_next_version_for,\n    RequestInfo,\n)\nfrom data.latest.users import User, UserCreateRequest\nimport datetime\n\n\nclass ChangeDateOfBirthToDateInUser(VersionChange):\n    description = (\n        \"Change 'User.date_of_birth' field type to date instead of \"\n        \"a datetime because storing the exact time is unnecessary.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(User).field(\"date_of_birth\").had(type=datetime.datetime),\n    )\n\n    @convert_request_to_next_version_for(UserCreateRequest)\n    def add_time_field_to_request(request: RequestInfo):\n        request.body[\"time_of_birth\"] = request.body[\"date_of_birth\"].time()\n</code></pre> </li> <li> <p>Regenerate the versioned schemas</p> </li> <li>Within your business logic, create the datetime that you will put into the database by combining <code>date_of_birth</code> field and <code>time_of_birth</code> field</li> </ol> <p>See how we did not need to use convert_response_to_previous_version_for? We do not need to migrate anything because moving from <code>datetime</code> to <code>date</code> is easy: our database data already contains datetimes so pydantic will automatically narrow them to dates for responses if necessary. We also do not need to change anything about <code>date_of_birth</code> in the requests of older versions because our schema of the new version will automatically cast <code>datetime</code> to <code>date</code>.</p> <p>This whole process was a bit complex so let us break it down a little:</p> <ol> <li><code>date_of_birth</code> field is a datetime in 2000 but a date in 2001.</li> <li>We needed some way to keep the 2000 behavior without allowing users in 2001 to use it. Cadwyn always converts all requests to the latest version but the latest version doesn't have any time information in this case. The solution is to introduce an internal schema which will include everything from latest plus the time information.</li> <li>When we receive a request from 2000, our migration fills up <code>time_of_birth</code> field. When we receive a request from 2001, the default value of <code>time(0, 0, 0)</code> is used.</li> <li>Internally we keep working with datetimes. Now we build them from <code>date_of_birth</code> and <code>time_of_birth</code> fields.</li> <li>When we return a response, we always return a datetime for <code>date_of_birth</code>. However, it is automatically converted to date by pydantic in 2001</li> </ol> <p>Thus, we have kept old behavior, added new constrained behavior, and minimized the impact on our business logic as business logic simply doesn't know that <code>date_of_birth</code> in requests was ever a datetime and that <code>date_of_birth</code> in responses is ever a date. All of this information is hidden in our migration which will likely never change.</p>"},{"location":"recipes/#incompatible-narrowingchange","title":"Incompatible narrowing/change","text":"<p>It is data versioning.</p>"},{"location":"recipes/#schema-field-type-expansion-including-enum-expansion","title":"Schema field type expansion (including enum expansion)","text":"<p>Let's say that our clients could choose a <code>role</code> for our users. Originally, it was only possible to choose <code>admin</code> or <code>regular</code> but we would like to expand it to <code>moderator</code> which has all the powers of an admin except that moderators cannot assign other admins.</p> <p>This is not a breaking change in terms of requests but it can be a breaking change in terms of responses.</p> <p>So if you do consider it a breaking change in terms of responses, you should do the following:</p> <ol> <li>Add <code>moderator</code> value into <code>data.latest.users.UserRoleEnum</code></li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code>:</p> <pre><code>from cadwyn.structure import (\n    VersionChange,\n    enum,\n    convert_response_to_previous_version_for,\n    ResponseInfo,\n)\nfrom data.latest.users import UserRoleEnum, UserResource\nimport datetime\n\n\nclass AddModeratorRoleToUser(VersionChange):\n    description = (\n        \"Add 'moderator' role to users that represents an admin that \"\n        \"cannot create or remove other admins. This allows for a \"\n        \"finer-grained permission control.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        enum(UserRoleEnum).didnt_have(\"moderator\"),\n    )\n\n    @convert_response_to_previous_version_for(UserResource)\n    def change_moderator_to_regular(response: ResponseInfo):\n        if response.body[\"role\"] == \"moderator\":\n            response.body[\"role\"] = \"regular\"\n</code></pre> </li> <li> <p>Regenerate the versioned schemas</p> </li> </ol> <p>We convert moderators to regulars in older versions because it is a safer choice for our users.</p>"},{"location":"recipes/#why-enum-expansion-is-a-breaking-change-for-responses","title":"Why enum expansion is a breaking change for responses","text":"<p>Let's that our schema includes a list that contains euros and/or dollars. Using our framework for unmarshalling JSON, we take the JSON string and try to convert it into the list of euros and/or dollars. If we suddenly see Georgian lari there -- our unmarshalling framework freaks out because the list is not what it expected, which makes adding an enum value a breaking change when you have a list of items.</p> <p>To be more precise: If I, as a client, expect <code>Array&lt;Euro | Dollar&gt;</code>, then <code>Array&lt;Euro&gt;</code> would be a compatible response and <code>Array&lt;Dollar&gt;</code> would be a compatible response BUT <code>Array&lt;Euro | Dollar | Lari&gt;</code> would be an incompatible response. That is the case because <code>Array&lt;Euro | Dollar | Lari&gt;</code> is a not a subtype of <code>Array&lt;Euro | Dollar&gt;</code> while <code>Array&lt;Euro&gt;</code> is.</p> <p>In a sense, extending an enum that has <code>USD</code> with <code>USD | EUR</code> is equivalent to turning an <code>int</code> field into an <code>int | str</code> field, which is a breaking change. Hence extending an enum is often a breaking change and thus we might not need to solve this problem at all.</p> <p>Additional resources:</p> <ul> <li>https://github.com/OAI/OpenAPI-Specification/issues/1552</li> <li>https://users.rust-lang.org/t/solved-is-adding-an-enum-variant-a-breaking-change/26721/5</li> <li>https://github.com/graphql/graphql-js/issues/968</li> <li>https://medium.com/@jakob.fiegerl/java-jackson-enum-de-serialization-with-rest-backward-compatibility-9c3ec85ac13d</li> </ul>"},{"location":"recipes/#responses","title":"Responses","text":"<p>In these sections, we'll be working with our user's response model: <code>data.latest.users.UserResource</code>. Note that the main theme here is \"Will I be able to serialize this change to any of my versions?\" as any change to responses can make them incompatible with the data in your database.</p>"},{"location":"recipes/#response-schema-field-addition","title":"Response schema field addition","text":"<p>Let's say that we decided to expose the creation date of user's account with a <code>created_at</code> field in our API. This is not a breaking change so a new version is completely unnecessary. However, if you believe that you absolutely have to make a new version, refer to the ... section which lists the actions you would need to perform in such a situation.</p> <p>The recommended approach:</p> <ol> <li>Add <code>created_at</code> field into <code>data.latest.users.UserResource</code></li> <li>Regenerate the versioned schemas</li> </ol> <p>Now you have everything you need at your disposal: field <code>created_at</code> is available in all versions and your users do not even need to do any extra actions. Just make sure that the data for it is available in all versions too. If it's not: make the field optional.</p>"},{"location":"recipes/#response-schema-field-removal","title":"Response schema field removal","text":"<p>Let's say that our API has a mandatory <code>UserResource.date_of_birth</code> field. Let's also say that our API has previously exposed user's zodiac sign. Our analysts have decided that it does not make sense to store or send this information as it does not affect the functionality and can be inferred from date of birth.</p> <ol> <li>Remove <code>zodiac_sign</code> field from <code>data.latest.users.UserResource</code></li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code>:</p> <pre><code>from cadwyn.structure import VersionChange, schema\nfrom data.latest.users import UserResource\nfrom pydantic import Field\n\n\nclass RemoveZodiacSignFromUser(VersionChange):\n    description = (\n        \"Remove 'zodiac_sign' field from UserResource because \"\n        \"it can be inferred from user's date of birth and because \"\n        \"only a small number of users has utilized it.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(UserResource)\n        .field(\"zodiac_sign\")\n        .existed_as(type=str, info=Field(description=\"User's magical sign\")),\n    )\n</code></pre> </li> <li> <p>Regenerate the versioned schemas</p> </li> </ol> <p>Thanks to the version change above, your old schemas will now include <code>zodiac_sign</code> field but your new schemas will stay the same. Don't remove the zodiac business logic from your router because the old version will still need it. So you always return the zodiac sign but the schemas of the latest version will ignore it.</p> <p>You can remove the logic for calculating and returning the zodiac sign after version <code>2000-01-01</code> gets deleted.</p>"},{"location":"recipes/#path-changes","title":"Path changes","text":""},{"location":"recipes/#path-addition","title":"Path addition","text":"<p>It is not a breaking change so it's recommended to simply add it to all versions. If you believe that you still need it, you can use the following migration.</p>"},{"location":"recipes/#path-deletion","title":"Path deletion","text":"<p>TODO</p>"},{"location":"recipes/#behavior","title":"Behavior","text":"<p>First, ask yourself: are you sure there really needs to be a behavioral change? Are you sure it is not possible to keep the same logic for both versions? Or at least make the behavior depend on the received data? Behavioral changes (or side effects) are the least maintainable part of almost any versioning approach. They produce the largest footprint on your code so if you are not careful -- your logic will be littered with version checks.</p> <p>But if you are certain that you need to make a breaking behavioral change, Cadwyn has all the tools to minimize its impact as much as possible.</p> <p>The following sections are all done using a version change with side effects.</p>"},{"location":"recipes/#calling-endpoint-causes-unexpected-data-modifications","title":"Calling endpoint causes unexpected data modifications","text":""},{"location":"recipes/#calling-endpoint-doesnt-cause-expected-data-modifications","title":"Calling endpoint doesn't cause expected data modifications","text":""},{"location":"recipes/#calling-endpoint-doesnt-cause-expected-additional-actions-eg-webhooks","title":"Calling endpoint doesn't cause expected additional actions (e.g. Webhooks)","text":""},{"location":"recipes/#errors","title":"Errors","text":""},{"location":"recipes/#error-status-or-message-change","title":"Error status or message change","text":""},{"location":"recipes/#new-error-introduced","title":"New error introduced","text":""},{"location":"recipes/#old-error-removed","title":"Old error removed","text":""},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#pydantic","title":"Pydantic","text":"<p>Cadwyn supports both Pydantic 1 and Pydantic 2 so you can pick your preferred version without any issue.</p>"},{"location":"reference/#cadwyns-flow","title":"Cadwyn's flow","text":"<p>Cadwyn aims to be the most accurate and sophisticated API Versioning model out there. First of all, you maintain zero duplicated code yourself. Usually, in API versioning you would need to duplicate and maintain at least some layer of your applicaton. It could be the database, business logic, schemas, and endpoints. Cadwyn only duplicates your:</p> <ul> <li>schemas but you do not maintain the duplicates -- you only regenerate it when necessary</li> <li>endpoints but only in runtime so you do not need to maintain the duplicates</li> </ul> <p>You define your database, business logic, routes, and schemas only once. Then, whenever you release a new API version, you use Cadwyn's version change DSL to describe how to convert your app to the previous version. So your business logic and database stay intact and always represent the latest version while the version changes make sure that your clients can continue using the previous versions without ever needing to update their code.</p>"},{"location":"reference/#service-structure","title":"Service structure","text":"<p>The service structure with Cadwyn is fairly straighforward. See the example service or follow the steps above:</p> <ol> <li>Define a VersionBundle where you add your first version.</li> <li>Create a <code>data/latest</code> directory and add your latest version of schemas there. This will serve as a template directory for future code generation.</li> <li>Run code generation that will create generated versions of your <code>latest</code> directory next to it.</li> <li>Create a Cadwyn app that you will use instead of <code>FastAPI</code>. Pass imported <code>data/latest</code> and your <code>VersonBundle</code> to it.</li> <li>Create a VersionedAPIRouter that you will use for defining your versioned routes.</li> <li>Include this router and any other versioned routers into your <code>Cadwyn</code> app. It will duplicate your router in runtime for each API version.</li> </ol> <p>The recommended directory structure for cadwyn is as follows:</p> <pre><code>\u251c\u2500\u2500 data\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 unversioned\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 users.py\n\u2502   \u2514\u2500\u2500 latest          # The latest version of your schemas goes here\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 users.py\n\u2514\u2500\u2500 versions\n    \u251c\u2500\u2500 __init__.py     # Your version bundle goes here\n    \u2514\u2500\u2500 v2001_01_01.py  # Your version changes go here\n</code></pre> <p>You can structure your business logic, database, and all other parts of your application in any way you like.</p> <p>That's it! Your service is ready to be versioned. We can now use the most powerful feature of Cadwyn: version changes.</p>"},{"location":"reference/#main-app","title":"Main App","text":"<p>Cadwyn's standard usage is done with a single customized FastAPI app: <code>cadwyn.Cadwyn</code>. It accepts all the same arguments as <code>FastAPI</code> three more keyword-only arguments:</p> <ul> <li>Required <code>versions: VersionBundle</code> describes all versions within your application</li> <li>Required <code>latest_schemas_package: ModuleType</code> is your latest package that contains the latest versions of your versioned schemas</li> <li>Optional <code>api_version_header_name: str = \"x-api-version\"</code> is the header that Cadwyn will use for routing to different API versions of your app</li> </ul> <p>After you have defined a main app, you can add versioned API routers to it using <code>Cadwyn.generate_and_include_versioned_routers(*routers)</code></p> <pre><code>from cadwyn import VersionedAPIRouter, Cadwyn\nfrom versions import my_version_bundle\nfrom data import latest\n\n\nrouter = VersionedAPIRouter(prefix=\"/users\")\n\n\n@router.get(\"/users/\", tags=[\"users\"])\nasync def read_users():\n    return [{\"username\": \"Rick\"}, {\"username\": \"Morty\"}]\n\n\n@router.get(\"/users/{username}\", tags=[\"users\"])\nasync def read_user(username: str):\n    return {\"username\": username}\n\n\napp = Cadwyn(versions=my_version_bundle, latest_schemas_package=latest)\napp.generate_and_include_versioned_routers(router)\n</code></pre> <p>That's it! <code>generate_and_include_versioned_routers</code> will generate all versions of your routers based on the <code>versions</code> argument and will use schemas from the versioned schema directories parallel to <code>latest_schema_package</code>.</p>"},{"location":"reference/#routing","title":"Routing","text":"<p>Cadwyn is built on header-based routing. First, we route requests to the appropriate API version based on the version header (<code>x-api-version</code> by default). Then we route by the appropriate url path and method. Currerntly, Cadwyn only works with ISO date-based versions (such as <code>2022-11-16</code>). If the user sends an incorrect API version, Cadwyn picks up the closest lower applicable version. For example, <code>2022-11-16</code> in request can be matched by <code>2022-11-15</code> and <code>2000-01-01</code> but cannot be matched by <code>2022-11-17</code>. See more details in verselect.</p> <p>However, header-based routing is only the standard way to use Cadwyn. If you want to use any other sort of routing, you can use Cadwyn directly through <code>cadwyn.generate_versioned_routers</code>. Just remember to update the <code>VersionBundle.api_version_var</code> variable each time you route some request to a version. This variable allows Cadwyn to do side effects and data migrations.</p>"},{"location":"reference/#versionedapirouter","title":"VersionedAPIRouter","text":"<p>Cadwyn has its own API Router class: <code>cadwyn.VersionedAPIRouter</code>. You are free to use a regular <code>fastapi.APIRouter</code> but <code>cadwyn.VersionedAPIRouter</code> has a special decorator <code>only_exists_in_older_versions(route)</code> which allows you to define routes that have been previously deleted. First you define the route and than add this decorator to it.</p>"},{"location":"reference/#cli","title":"CLI","text":"<p>Cadwyn has an optional CLI interface that can be installed with <code>pip install cadwyn[cli]</code>. Run <code>cadwyn --version</code> to check current version of Cadwyn.</p>"},{"location":"reference/#code-generation","title":"Code generation","text":"<p>Cadwyn generates versioned schemas and everything related to them from latest version. These versioned schemas will be automatically used in requests and responses for versioned API routes. There are two methods of generating code: using a function and using the CLI:</p>"},{"location":"reference/#function-interface","title":"Function interface","text":"<p>You can use <code>cadwyn.generate_code_for_versioned_packages</code> which accepts a <code>template_module</code> (a directory which contains the latest versions) and <code>versions</code> which is the <code>VersionBundle</code> from which to generate versions.</p>"},{"location":"reference/#cli-interface","title":"CLI interface","text":"<p>The interface is the same to the function one and is a shorthand for simple cases:</p> <ul> <li><code>cadwyn generate-code-for-versioned-packages path.to.latest.package path.to.version.bundle:my_version_bundle</code></li> <li><code>cadwyn generate-code-for-versioned-packages path.to.latest.package path.to.version.bundle:func_that_returns_version_bundle</code></li> </ul>"},{"location":"reference/#note","title":"Note","text":"<ul> <li>You don't use the system path style for both arguments. Instead, imagine that you are importing these modules in python -- that's the way you want to write down the paths.</li> <li>Take a look at how we point to our version bundle. We use \":\" to say that it's a variable within the specified module</li> </ul>"},{"location":"reference/#version-changes","title":"Version Changes","text":"<p>Version changes are the backbone of Cadwyn. They give you an ability to describe things like \"This field in that schema had a different name in an older version\" or \"this endpoint was deleted in the latest version\". Whenever add a new version, it means that you wish to make a bunch of breaking changes in your API without affecting your users.</p> <p>First, you apply the breaking changes to your schemas and endpoints. In Cadwyn, you always work on the latest version of your application so you change your schemas first, just like you would do in an app without API Versioning.</p> <p>Second, you need to gather your breaking changes into groups. Let's say that you want to rename the field \"creation_date\" into \"created_at\" but you also want to delete the endpoint \"GET /v1/tax_ids\": these changes are unrelated so they should be put into different groups. On the other hand, deletion of \"POST /v1/tax_ids\" endpoint should go into the same group as its GET counterpart. These groups are very important to make the changes easily understandable for both your users and your developers.</p> <p>Then, you describe each group with a version change:</p> <pre><code># versions/v2023_02_10.py\n\nfrom cadwyn.structure import VersionChange, endpoint\n\n\nclass RemoveTaxIDEndpoints(VersionChange):\n    description = \"Remove `GET /v1/tax_ids` and `POST /v1/tax_ids` endpoints\"\n    instructions_to_migrate_to_previous_version = (\n        endpoint(\"/v1/tax_ids\", [\"GET\", \"POST\"]).existed,\n    )\n</code></pre> <p>Then you add your version change class(es) into your version bundle to activate it:</p> <pre><code># versions/__init__.py\n\nfrom cadwyn.structure import VersionBundle, Version\nfrom datetime import date\n\nfrom .v2023_02_10 import RemoveTaxIDEndpoints\n\n\nversions = VersionBundle(\n    Version(date(2023, 2, 10), RemoveTaxIDEndpoints), Version(date(2022, 11, 16))\n)\n</code></pre> <p>Now let's discuss what each of these parts does and why:</p>"},{"location":"reference/#versionchange","title":"VersionChange","text":"<p><code>VersionChange</code> classes describe each atomic group of business capabilities that you have altered in a version.</p>"},{"location":"reference/#versionchange__name__","title":"VersionChange.__name__","text":"<p>The name of the version change, <code>RemoveTaxIDEndpoints</code>, describes what breaking change has happened. It must be a verb and it is the best resource for your new developers to quickly understand what happened between the versions. Do not be shy to use really long names -- it is better to have a long name than to create a misunderstanding. Avoid generic names such as <code>RefactorUserFields</code>. Better have an ugly name such as <code>RenameCreationDatetimeAndUpdateDatetimeToCreatedAtAndUpdatedAt</code> then to have a generic name such as <code>RefactorFields</code>. Because after just a few of such version changes, your versioning structure can become completely unreadable:</p> <pre><code>versions = VersionBundle(\n    Version(date(2023, 5, 9), ChangeCreateLogic, AddRequiredFields),\n    Version(date(2023, 4, 2), DeleteEndpoint, ChangeFields, RenameFields),\n    Version(date(2023, 2, 10), RenameEndpoints, RefactorFields),\n    Version(date(2022, 11, 16)),\n)\n</code></pre>"},{"location":"reference/#versionchangedescription","title":"VersionChange.description","text":"<p>The description field of your version change must be even more detailed. In fact, it is intended to be the name and the summary of the version change for your clients. It must clearly state to you clients what happened and why. So you need to make it grammatically correct, detailed, concrete, and written for humans. Note that you do not have to use a strict machine-readable format -- it is a portion of documentation, not a set of intructions. Let's take Stripe's description to one of their version changes as an example:</p> <pre><code>Event objects (and webhooks) will now render `request` subobject that contains a request ID and idempotency key instead of just a string request ID.\n</code></pre> <p>It is concise, descriptive, and human-readable -- just like any good documentation. Now let's look at the bad description:</p> <pre><code>Migration from first version (2022-11-16) to 2023-09-01 version.\nChanges:\n* Changed schema for 'POST /v1/tax_ids' endpoint\n</code></pre> <ul> <li>Its first line, <code>Migration from first version (2022-11-16) to 2023-09-01 version.</code>, duplicates the already-known information -- your developers will know which version <code>VersionChange</code> migrates to and from by its location in VersionBundle and most likely by its file name. Your clients will also know that because you can automatically infer this information from  So it is simply standing in the way of actually useful parts of the documentation</li> <li>Its second line, <code>Changes:</code>, does not make any sense as well because description of a <code>VersionChange</code> cannot describe anything but changes. So again, it's stating the obvious and making it harder for our readers to understand the crux of the change</li> <li>Its third line, <code>Changed schema for 'POST /v1/tax_ids' endpoint</code>, gives both too much and too little information. First of all, it talks about changing schema but it never mentions what exactly changed. Remember: we are doing this to make it easy for our clients to migrate from one version to another. Insteaad, it is much better to mention the openapi model name that you changed, the fields you changed, and why you changed them</li> </ul>"},{"location":"reference/#versionchangeinstructions_to_migrate_to_previous_version","title":"VersionChange.instructions_to_migrate_to_previous_version","text":"<p>In Cadwyn, you use the latest version. This attribute is a way for you to describe how your schemas and endpoints looked in previous versions so that Cadwyn can guess code generation and route generation to recreate the old schemas and endpoints for your clients. So you only need to maintain your latest schemas and your migrations while Cadwyn takes care of the rest. In fact, you spend barely any effort on maintaining your migrations because they are effectively immutable -- they describe the breaking changes that happened in the past so there is no need to ever change them.</p> <p>This approach of maintaining the present and describing the past might appear weird. You just need to form the correct mindset which is counter-intuitive at first but after just one or two attempts at versioning you will see how much sense this approach makes.</p>"},{"location":"reference/#data-migrations","title":"Data migrations","text":"<p>Let's say that we renamed the field <code>creation_date</code> into <code>created_at</code>. We have altered our schemas -- that's great! But when our clients send us requests using the old versions of our API -- we will still get the data where we have <code>creation_date</code> instead of <code>created_at</code>. How do we solve this? Well, in Cadwyn your business logic never receives requests of the old versions. Instead, it receives only the requests of the latest version. So when you define a version change that renames a field, you need to also define how to convert the request body from the old version to the newer version. For example:</p> <pre><code>from cadwyn.structure import VersionChange, schema, convert_request_to_next_version_for\nfrom data.latest.invoices import InvoiceCreateRequest\n\n\nclass RemoveTaxIDEndpoints(VersionChange):\n    description = \"Rename `Invoice.creation_date` into `Invoice.created_at`.\"\n    instructions_to_migrate_to_previous_version = (\n        schema(InvoiceCreateRequest).field(\"creation_date\").had(name=\"created_at\"),\n    )\n\n    @convert_request_to_next_version_for(InvoiceCreateRequest)\n    def rename_creation_date_into_created_at(request: RequestInfo):\n        request.body[\"created_at\"] = request.body.pop(\"creation_date\")\n</code></pre> <p>Notice how we specified the schema for <code>InvoiceCreateRequest</code> in our migration? This will signal to Cadwyn to apply it to all routes that have this schema as their body.</p> <p>Now we have not only described how schemas changed but we have also described how to migrate a request of the old version to the new version. When Cadwyn receives a request of a particular version, the request is first validated against the schema of that particular version. Then Cadwyn applies all request migrations until the latest version to migrate the request to latest. So now your business logic receives the latest version of the request yet for your clients you have two versions of your API -- you have added variability without introducing any complexity into your business logic.</p> <p>But wait.. What happens with the <code>Invoice</code> responses? Your business logic will now return <code>created_at</code> so your clients from old versions will be affected! Cadwyn has a tool for that too: we migrate our responses as well. Requests were migrated forward in versions but responses are migrated backward in versions! So your business logic returns a response of the latest version and Cadwyn will use your response migrations to migrate it back the version of your client's request:</p> <pre><code>from cadwyn.structure import (\n    VersionChange,\n    schema,\n    convert_request_to_next_version_for,\n    convert_response_to_previous_version_for,\n)\nfrom data.latest.invoices import BaseInvoice, InvoiceCreateRequest, InvoiceResource\n\n\nclass RemoveTaxIDEndpoints(VersionChange):\n    description = \"Rename `Invoice.creation_date` into `Invoice.created_at`.\"\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseInvoice).field(\"creation_date\").had(name=\"created_at\"),\n    )\n\n    @convert_request_to_next_version_for(InvoiceCreateRequest)\n    def rename_creation_date_into_created_at(request: RequestInfo):\n        request.body[\"created_at\"] = request.body.pop(\"creation_date\")\n\n    @convert_response_to_previous_version_for(InvoiceResource)\n    def rename_created_at_into_creation_date(response: ResponseInfo):\n        response.body[\"creation_date\"] = response.body.pop(\"created_at\")\n</code></pre> <p>Notice how we specified the schema for <code>InvoiceResource</code> in our migration? This will signal to Cadwyn to apply it to all routes that have this schema as their <code>response_model</code>. Notice also that we now use <code>BaseInvoice</code> in our instructions -- let's imagine that it is the parent of both <code>InvoiceCreateRequest</code> and <code>InvoiceResource</code> so renaming it there will rename it in these schemas as well. You can, however, apply the instructions to both individual schemas instead of their parent if you want to.</p> <p>Now our request comes, Cadwyn migrates it to the latest version using our request migration, then we do our business logic, return the latest response from it, and Cadwyn migrates it back to the request version. Does our business logic or database know about the fact that we have two versions? No, not at all! It is zero-cost. Imagine how beneficial it is when you support not two but two hundred versions.</p> <p></p> <p>Notice how we used the latest versions of our schemas in our migration -- this pattern can be found everywhere in Cadwyn. You use the latest version of your schemas to describe what happened to all other versions because other versions might not exist when you are defining migrations for them.</p>"},{"location":"reference/#internal-representations","title":"Internal representations","text":"<p>We have only reviewed simplistic cases so far. But what happens when you cannot just migrate your data that easily? It can happen because your earlier versions had more data than your newer versions. Or that data had more formats.</p> <p>Let's imagine that previously the <code>User</code> schema had a list of addresses but now we want to make a breaking change and turn them into a single address. The naive migration will just take the first address from the list for requests and turn that one address into a list for responses like so:</p> <pre><code>from cadwyn.structure import (\n    VersionChange,\n    schema,\n    convert_request_to_next_version_for,\n    convert_response_to_previous_version_for,\n)\nfrom data.latest.users import User\n\n# THIS IS AN EXAMPLE OF A BAD MIGRATION\nclass RemoveTaxIDEndpoints(VersionChange):\n    description = \"Users now have `address` field instead of `addresses`\"\n    instructions_to_migrate_to_previous_version = (\n        schema(User).field(\"address\").didnt_exist,\n        schema(User).field(\"addresses\").existed_as(type=list[str]),\n    )\n\n    @convert_request_to_next_version_for(User)\n    def turn_addresses_into_a_single_item(request: RequestInfo):\n        addresses = request.body.pop(\"addresses\")\n        # The list could have been empty in the past so new \"address\"\n        # field must be nullable.\n        request.body[\"address\"] = addresses[0] if addresses else None\n\n    @convert_response_to_previous_version_for(User)\n    def turn_address_into_a_list(response: ResponseInfo):\n        response.body[\"addresses\"] = [response.body.pop(\"address\")]\n</code></pre> <p>But this will not work. Now when the user from the old version asks us to save three addresses, we will in fact save only one. Old data is also going to be affected -- if old users had multiple addresses, we will only be able to return one of them. This is bad -- we have made a breaking change!</p> <p>In order to solve this problem, Cadwyn uses a concept of internal representations. An internal representation of your data is like a database entry of your data -- it is its latest version plus all the fields that are incompatible with the latest API version. If we were talking about classes, then internal representation would be a child of your latest schemas -- it has all the same data and a little more. Essentially your internal representation of user object can contain much more data than your latest schemas.</p> <p>The migrations diagram we showed before is in fact a simplified version of truth. In fact, your requests do not get migrated to latest -- they get migrated to the internal representation of their data that is really similar to latest. Same happens with your responses -- you do not respond with and migrate from the latest version of your data, you respond with its internal representation which is really close to the actual latest schemas.</p> <p>In responses, returning the internal representation is simple: just return your database model or a dict with everything you need for all your versions. In the user address example, we would continue storing the list of addresses in our database but then add the single address to our response. Latest schemas will simply strip it but our older schemas will be able to use it!</p> <pre><code># in your business logic\n\nreturn {\"address\": user.addresses[0] if user.addresses else None, **user}\n</code></pre> <p>So now your migration will look like the following:</p> <pre><code>from cadwyn.structure import (\n    VersionChange,\n    schema,\n    convert_request_to_next_version_for,\n    convert_response_to_previous_version_for,\n)\nfrom data.latest.users import User\n\n\nclass RemoveTaxIDEndpoints(VersionChange):\n    description = \"Users now have `address` field instead of `addresses`\"\n    instructions_to_migrate_to_previous_version = (\n        schema(User).field(\"address\").didnt_exist,\n        schema(User).field(\"addresses\").existed_as(type=list[str]),\n    )\n</code></pre> <p>Yes, we do not need any of the migrations anymore because responses are handled automatically. But why don't we need request migrations? That's because we use an internal representation there too.</p>"},{"location":"reference/#internal-request-body-representations","title":"Internal request body representations","text":"<p>Let's remember that our <code>User</code> model had multiple addresses in the old version but now has only one address in the new version. We handled it in responses by continuing to store the list of addresses and then returning all of them with each response. In requests, we have a similar trick. When you create the version with only one address, you need to define the internal representation of your user's creation request which will effectively store all addresses consistently for all versions instead of just one address:</p> <pre><code># In data/unversioned/users.py\n\nfrom .versioned_schemas.latest import User\nfrom pydantic import root_validator, PrivateAttr\n\n\nclass InternalUserCreateRequest(User):\n    addresses: list[str] = Field(default_factory=list)\n    # This helps us delete address from our fields\n    address = PrivateAttr()\n\n    @root_validator(pre=True)\n    def move_address_from_latest_into_addresses(\n        cls, values: dict[str, Any]\n    ) -&gt; dict[str, Any]:\n        if values.get(\"address\") is not None:\n            values[\"addresses\"] = [values.pop(\"address\")]\n        return values\n</code></pre> <p>Whenever this model receives an <code>address</code>, it will add it into <code>addresses</code> so now our latest requests can also be converted into our internal representation. Now all that's left is to tell Cadwyn to wrap all requests into this schema. Let's go to the definition of <code>POST /v1/users</code></p> <pre><code>from cadwyn import VersionedAPIRouter, InternalRepresentationOf\nfrom typing import Annotated\nfrom data.latest.users import User\nfrom data.unversioned.users import InternalUserCreateRequest\n\nrouter = VersionedAPIRouter(prefix=\"/v1/users\")\n\n\n@router.post(\"\", response_model=User)\ndef create_user(\n    payload: Annotated[InternalUserCreateRequest, InternalRepresentationOf[User]]\n):\n    ...\n</code></pre> <p>This type hint will tell Cadwyn that this route has public-facing schema of <code>User</code> that Cadwyn will use for validating all requests. Cadwyn will always use <code>InternalUserCreateRequest</code> when pushing body field into your business logic instead of <code>User</code>. Note that users will not be able to use any fields from the internal representation and their requests will still be validated by your regular schemas. So even if you added a field <code>foo</code> in an internal representation, and your user has passed this field in the body of the request, this field will not get to the internal representation because it will be removed at the moment of request validation (or even an error will occur if you use <code>extra=\"ignore\"</code>). OpenAPI will also only use the public schemas, not the internal ones.</p>"},{"location":"reference/#versionbundle","title":"VersionBundle","text":"<p><code>VersionBundle</code> is your single source of truth for your list of versions. It contains your list of versions and all version changes associated with them. Each version change is a single group of breaking changes. Each <code>Version</code> contains a group of version changes that caused this version to be created. So for example, if I deleted an endpoint <code>POST /v1/tax_ids</code> in version <code>2023-02-10</code>, then I'll add the version change for deleting that endpoint into <code>2023-02-10</code>. For example:</p> <pre><code># versions/__init__.py\n\nfrom cadwyn.structure import VersionBundle, Version\nfrom datetime import date\n\nfrom .v2023_02_10 import RemoveTaxIDEndpoints\n\n\nversions = VersionBundle(\n    Version(date(2023, 2, 10), RemoveTaxIDEndpoints), Version(date(2022, 11, 16))\n)\n</code></pre> <p>See how our first version, <code>2022-11-16</code> does not have any version changes? That is intentional! How can it have breaking changes if there are no versions before it?</p>"},{"location":"reference/#endpoints","title":"Endpoints","text":"<p>Note that the endpoint constructor contains a second argument that describes the methods of the endpoints you would like to edit. If you have two routes for a single endpoint and you put both of their methods into the instruction -- both of them are going to be changed as you would expect.</p>"},{"location":"reference/#defining-endpoints-that-didnt-exist-in-new-versions","title":"Defining endpoints that didn't exist in new versions","text":"<p>If you had an endpoint in old version but do not have it in a new one, you must still define it but mark it as deleted.</p> <pre><code>@router.only_exists_in_older_versions\n@router.get(\"/my_old_endpoint\")\nasync def my_old_endpoint():\n    ...\n</code></pre> <p>and then define it as existing in one of the older versions:</p> <pre><code>from cadwyn.structure import VersionChange, endpoint\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        endpoint(\"/my_old_endpoint\", [\"GET\"]).existed,\n    )\n</code></pre>"},{"location":"reference/#defining-endpoints-that-didnt-exist-in-old-versions","title":"Defining endpoints that didn't exist in old versions","text":"<p>If you have an endpoint in your new version that must not exist in older versions, you define it as usual and then mark it as \"non-existing\" in old versions:</p> <pre><code>from cadwyn.structure import VersionChange, endpoint\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        endpoint(\"/my_new_endpoint\", [\"GET\"]).didnt_exist,\n    )\n</code></pre>"},{"location":"reference/#changing-endpoint-attributes","title":"Changing endpoint attributes","text":"<p>If you want to change any attribute of your endpoint in a new version, you can return the attribute's value in all older versions like so:</p> <pre><code>from cadwyn.structure import VersionChange, endpoint\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        endpoint(\"/my_endpoint\", [\"GET\"]).had(description=\"My old description\"),\n    )\n</code></pre>"},{"location":"reference/#dealing-with-endpoint-duplicates","title":"Dealing with endpoint duplicates","text":"<p>Sometimes, when you're doing some advanced changes in between versions, you will need to rewrite your endpoint function entirely. So essentially you'd have the following structure:</p> <pre><code>from fastapi.params import Param\nfrom fastapi.headers import Header\nfrom typing import Annotated\nfrom cadwyn import VersionedAPIRouter\n\nrouter = VersionedAPIRouter()\n\n\n@router.only_exists_in_older_versions\n@router.get(\"/users\")\ndef get_users_by_name_before_we_started_using_params(\n    user_name: Annotated[str, Header()]\n):\n    \"\"\"Do some logic with user_name\"\"\"\n\n\n@router.get(\"/users\")\ndef get_users_by_name(user_name: Annotated[str, Param()]):\n    \"\"\"Do some logic with user_name\"\"\"\n</code></pre> <p>As you see, these two functions have the same methods and paths. And when you have many versions, you can have even more functions like these two. So how do we ask cadwyn to restore only one of them and delete the other one?</p> <pre><code>from cadwyn.structure import VersionChange, endpoint\n\n\nclass UseParamsInsteadOfHeadersForUserNameFiltering(VersionChange):\n    description = (\n        \"Use params instead of headers for user name filtering in GET /users \"\n        \"because using headers is a bad API practice in such scenarios.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        # We don't have to specify the name here because there's only one such deleted endpoint\n        endpoint(\"/users\", [\"GET\"]).existed,\n        # We do have to specify the name because we now have two existing endpoints after the instruction above\n        endpoint(\"/users\", [\"GET\"], func_name=\"get_users_by_name\").didnt_exist,\n    )\n</code></pre> <p>So by using a more concrete <code>func_name</code>, we are capable to distinguish between different functions that affect the same routes.</p>"},{"location":"reference/#enums","title":"Enums","text":"<p>All of the following instructions affect only code generation.</p>"},{"location":"reference/#adding-enum-members","title":"Adding enum members","text":"<p>Note that adding enum members can be a breaking change unlike adding optional fields to a schema. For example, if I return a list of entities, each of which has some type, and I add a new type -- then my client's code is likely to break.</p> <p>So I suggest adding enum members in new versions as well.</p> <pre><code>from cadwyn.structure import VersionChange, enum\nfrom enum import auto\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        enum(my_enum).had(foo=\"baz\", bar=auto()),\n    )\n</code></pre>"},{"location":"reference/#removing-enum-members","title":"Removing enum members","text":"<pre><code>from cadwyn.structure import VersionChange, enum\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        enum(my_enum).didnt_have(\"foo\", \"bar\"),\n    )\n</code></pre>"},{"location":"reference/#schemas","title":"Schemas","text":"<p>All of the following instructions affect only code generation.</p>"},{"location":"reference/#add-a-field","title":"Add a field","text":"<pre><code>from pydantic import Field\nfrom cadwyn.structure import VersionChange, schema\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(MySchema)\n        .field(\"foo\")\n        .existed_as(type=list[str], info=Field(description=\"Foo\")),\n    )\n</code></pre> <p>You can also specify any string in place of type:</p> <pre><code>schema(MySchema).field(\"foo\").existed_as(type=\"AnythingHere\")\n</code></pre> <p>It is often the case that you want to add a type that has not been imported in your schemas yet. You can use module import adding to solve this issue.</p>"},{"location":"reference/#remove-a-field","title":"Remove a field","text":"<pre><code>from cadwyn.structure import VersionChange, schema\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(MySchema).field(\"foo\").didnt_exist,\n    )\n</code></pre>"},{"location":"reference/#change-a-field","title":"Change a field","text":"<pre><code>from cadwyn.structure import VersionChange, schema\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(MySchema).field(\"foo\").had(description=\"Foo\"),\n    )\n</code></pre>"},{"location":"reference/#defaults-warning","title":"DEFAULTS WARNING","text":"<p>If you add <code>default</code> or <code>default_factory</code> into the old version of a schema -- it will not manifest in code automatically. Instead, you should add both the <code>default</code> or <code>default_factory</code>, and then also add the default value using a request migration.</p> <p>This happens because of how Cadwyn works with pydantic and sadly cannot be changed:</p> <p>Cadwyn:</p> <ol> <li>Receives the request of some version <code>V</code></li> <li>Validates the request using the schemas from <code>V</code></li> <li>Marshalls the unmarshalled request body into a raw data structure using <code>BaseModel.dict</code> (<code>BaseModel.model_dump</code> in Pydantic v2) using exclude_unset=True</li> <li>Passes the request through all request migrations from <code>V</code> to <code>latest</code></li> <li>Validates the request using <code>latest</code> schemas</li> </ol> <p>The part that causes the aforementioned problem is our usage of <code>exclude_unset=True</code>. Sadly, when we use it, all default fields do not get set so <code>latest</code> does not receive them. And if <code>latest</code> does not have the same defaults (for example, if the field has no default and is required in <code>latest</code>), then an error will occur. If we used <code>exclude_unset=False</code>, then <code>exclude_unset</code> would lose all its purpose for the users of our library so we cannot abandon it. Instead, you should set all extra on step 4 in your request migrations.</p>"},{"location":"reference/#rename-a-schema","title":"Rename a schema","text":"<p>If you wish to rename your schema to make sure that its name is different in openapi.json:</p> <pre><code>from cadwyn.structure import VersionChange, schema\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(MySchema).had(name=\"OtherSchema\"),\n    )\n</code></pre> <p>which will replace all references to this schema with the new name.</p>"},{"location":"reference/#modules","title":"Modules","text":"<p>Oftentimes you start depending on new types in-between versions. For example, let's say that you depended on <code>Invoice</code> schema within your <code>data.latest.users</code> in older versions but now you do not. This means that once we run code generation and this type gets back into some annotation of some schema in <code>data.latest.users</code> -- it will not be imported because it was not imported in <code>latest</code>. To solve problems like this one, we have <code>module</code> instructions:</p> <pre><code>from cadwyn.structure import VersionChange, module\nimport data.latest.users\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        module(data.latest.users).had(import_=\"from .invoices import Invoice\"),\n    )\n</code></pre> <p>Which will add-in this import at the top of <code>users</code> file in all versions before this version change.</p>"},{"location":"reference/#version-changes-with-side-effects","title":"Version changes with side effects","text":"<p>Sometimes you will use API versioning to handle a breaking change in your business logic, not in the schemas themselves. In such cases, it is tempting to add a version check and just follow the new business logic such as:</p> <pre><code>if api_version_var.get() &gt;= date(2022, 11, 11):\n    # do new logic here\n    ...\n</code></pre> <p>In cadwyn, this approach is highly discouraged. It is recommended that you avoid side effects like this at any cost because each one makes your core logic harder to understand. But if you cannot, then I urge you to at least abstract away versions and versioning from your business logic which will make your code much easier to read.</p> <p>WARNING: Side effects are the wrong way to do API Versioning. In 99% of time, you will need them. Please, think twice before using them. API Versioning is about having the same underlying app and data while just changing the schemas and api endpoints to interact with it. By introducing side effects, you leak versioning into your business logic and possibly even your data which makes your code much harder to support in the long term. If each side effect adds a single <code>if</code> to your logic, than after 100 versions with side effects, you will have 100 more <code>if</code>s. If used correctly, Cadwyn can help you support decades worth of API versions at the same time with minimal costs but side effects make it much harder to do. Changes in the underlying source, structure, or logic of your data should not affect your API or public-facing business logic.</p> <p>To simplify this, cadwyn has a special <code>VersionChangeWithSideEffects</code> class. It makes finding dangerous versions that have side effects much easier and provides a nice abstraction for checking whether we are on a version where these side effects have been applied.</p> <p>As an example, let's use the tutorial section's case with the user and their address. Let's say that we use an external service to check whether user's address is listed in it and return 400 response if it is not. Let's also say that we only added this check in the newest version.</p> <pre><code>from cadwyn.structure import VersionChangeWithSideEffects\n\n\nclass UserAddressIsCheckedInExternalService(VersionChangeWithSideEffects):\n    description = (\n        \"User's address is now checked for existense in an external service. \"\n        \"If it doesn't exist there, a 400 code is returned.\"\n    )\n</code></pre> <p>Then we will have the following check in our business logic:</p> <pre><code>from src.versions import versions, UserAddressIsCheckedInExternalService\n\n\nasync def create_user(payload):\n    if UserAddressIsCheckedInExternalService.is_applied:\n        check_user_address_exists_in_an_external_service(payload.address)\n    ...\n</code></pre> <p>So this change can be contained in any version -- your business logic doesn't know which version it has and shouldn't.</p>"},{"location":"reference/#api-version-header-and-context-variables","title":"API Version header and context variables","text":"<p>Cadwyn automatically converts your data to a correct version and has \"version checks\" when dealing with side effects as described in the section above. It can only do so using a special context variable that stores the current API version.</p> <p>You can also pass a different compatible contextvar to your <code>cadwyn.VersionBundle</code> constructor.</p>"},{"location":"theory/","title":"Theory","text":""},{"location":"theory/#types-of-api-versioning","title":"Types of API versioning","text":"<p>There are three ([1], [2]) main ways to version an API, each consequent being less safe but more convenient to both the API clients and maintainers. Essentially they can be classified by which layers of MVC they version.</p>"},{"location":"theory/#1-versioning-proxy-which-points-requests-to-versioned-apps","title":"1. Versioning proxy, which points requests to versioned apps","text":"<p>This approach versions all three layers: separate data, separate business logic, separate representation. Essentially you create a completely different app for each version. Your versions are indepent and cannot in any way affect each other. You can make any sorts of changes in future versions without worrying about breaking the old ones.</p> <p>This approach is the most expensive to support but if breaking old functionality is unacceptable and if you need to support a small number of versions (1-3), then this option is viable.</p> <p>Note that this is essentially data or application versioning, not API versioning anymore. If it is impossible for your user to freely move between API versions (back and forth), then you are probably doing a bit of data versioning yourself. It can simplify your app's logic but will significantly inconvenience your users because they will not be able to easily switch API versions without waiting for your team to help. Additionally, a single client will never be able to use two versions at the same time. At least not easily.</p> <p>Mostly used in older-style apps or in critical infrastructure where no mistakes are permitted</p>"},{"location":"theory/#2-one-router-which-points-requests-to-versioned-controllers","title":"2. One router, which points requests to versioned controllers","text":"<p>This approach versions business logic and representation layers while leaving data layer the same. You still have to duplicate all of your business logic but now your clients will be able to migrate between versions easily and you will be able to share some of the code between versions, thus lowering the amount of things you would need to duplicate.</p> <p>The problem with this method is that any refactoring will most likely have to happen in all versions at once. Any changes in the libraries they depend on will also require a change in all versions. When the number of versions starts to rise (&gt;2), this becomes a significant problem for the performance and morale of API maintainers.</p> <p>This is also the approach we have originally started with. It is likely the worst one out there due to its fake simplicity and actual complexity. In the long run, this approach is one of the hardest to support but most importantly: it's probably the hardest to migrate from.</p> <p>Popular in .NET environment and is likely the first choice of any API due to the simplicity of its implementation</p>"},{"location":"theory/#3-one-router-shared-controllers-which-respond-with-versioned-representations","title":"3. One router, shared controllers, which respond with versioned representations","text":"<p>This approach versions only the API itself. The business logic and data below the API is the same for all versions (with rare exceptions) so API maintainers have the pleasure of maintaining only one API version while users have the added benefit that non-breaking featurees and bugfixes will automatically be ported to their version. This is the only method that allows you to support a large number of versions because it has the least amount of duplication of all methods. This is usually accomplished by adding a separate layer that builds responses out of the data that your service returns. It can be a separate service, a framework, or just a set of functions.</p> <p>Note that in this method, the usage of data versioning now becomes an inconvenience to both API users and maintainers. See, when you have a single business logic for all versions, you might need additional conditionals and checks for versions where data structure or data itself has changed. That is in addition to pre-existing incoveniences for the users. However, sometimes it might still happen so our goal is to minimize the frequency and impact of data versioning.</p> <p>Popular in API-First tech giants that have to support backwards compatibility for a long time for a large number of clients</p> <p>Note that this approach actually has two important subtypes:</p>"},{"location":"theory/#i-duplication-based-response-building","title":"i. Duplication-based response building","text":"<p>The simplest possible builder: for each API version, we define a new request/response builder that builds the full response for the altered API routes or migrates the user request to the latest version. It is incredibly simple to implement but is not scalable at all. Adding values to all builders will require going through all of them with the hope of not making mistakes or typos. Trying to support more than 8-12 versions with this approach will still be challenging.</p> <p>We might think of smart ways of automating this approach to support a larger number of versions. For example, to avoid duplicating the entire builder logic every time, we can pick a template builder and only define differences in child builders. Let's pick the latest-version builder as template because it will never be deprecated deleted and our developers will have the most familiarity with it. Then we need to figure out a format to define changes between builders. We can remove a field from response, add a field, change the value of a field somehow, and/or change the type of a field. We'll need some DSL to describe all possible changes.</p> <p>Then we start thinking about API route differences. How do we describe them? Or do we just duplicate all routes? Do we maybe use inheritance? No matter what we do, we'll eventually also come to a DSL, which is why some tech giants have chosen approach ii.</p> <p>A code generation yaml-based version of this approach was used at SuperJob.</p>"},{"location":"theory/#ii-migration-based-response-building","title":"ii. Migration-based response building","text":"<p>This is effectively an automated version of approach i. It has the minimal possible amount of duplication compared to all other approaches. Using a specialized DSL, we define schema migrations for changes in our request and response schemas, we define compatibility gates to migrate our data in accordance with schema changes, and we define route migrations to change/delete/add any routes.</p> <p>This is the method that Stripe, Linkedin, and Intercom have picked and this is the method that Cadwyn implements for you.</p>"},{"location":"theory/#projects-like-cadwyn","title":"Projects like Cadwyn","text":"<p>The following projects are trying to accomplish similar results with a lot more limited functionality.</p> <ul> <li>https://github.com/sjkaliski/pinned</li> <li>https://github.com/phillbaker/gates</li> <li>https://github.com/lukepolo/laravel-api-migrations</li> <li>https://github.com/tomschlick/request-migrations</li> <li>https://github.com/keygen-sh/request_migrations</li> <li>https://github.com/binnev/djangorestframework_versioning</li> </ul>"},{"location":"tutorial/","title":"Tutorial","text":"<p>This guide provides a step-by-step tutorial for setting up automatic API versioning using Cadwyn. I will illustrate this with an example of a User API, where we will be implementing changes to a User's address. You can also see the advanced version of the service from this tutorial here.</p>"},{"location":"tutorial/#installation","title":"Installation","text":"<pre><code>pip install cadwyn\n</code></pre>"},{"location":"tutorial/#a-dummy-setup","title":"A dummy setup","text":"<p>The recommended directory structure for cadwyn is as follows:</p> <pre><code>\u251c\u2500\u2500 data\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 unversioned\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 users.py\n\u2502   \u2514\u2500\u2500 latest          # The latest version of your schemas goes here\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 users.py\n\u2514\u2500\u2500 versions\n    \u251c\u2500\u2500 __init__.py     # Your version bundle goes here\n    \u2514\u2500\u2500 v2001_01_01.py  # Your version changes go here\n</code></pre> <p>Here is an initial API setup where the User has a single address. We will be implementing two routes - one for creating a user and another for retrieving user details. We'll be using \"int\" for ID for simplicity. Please note that we will use a dict in place of a database for simplicity of our examples but do not ever do it in real life.</p> <p>The first API you come up with usually doesn't require more than one address -- why bother?</p> <p>So we create our file with schemas:</p> <pre><code># data/latest/users.py\nfrom pydantic import BaseModel\nimport uuid\n\n\nclass BaseUser(BaseModel):\n    address: str\n\n\nclass UserCreateRequest(BaseUser):\n    pass\n\n\nclass UserResource(BaseUser):\n    id: uuid.UUID\n</code></pre> <p>Then we create our version bundle which will keep track of our API versions:</p> <pre><code># versions/__init__.py\nfrom cadwyn.structure import Version, VersionBundle\nfrom datetime import date\n\n\nversion_bundle = VersionBundle(\n    Version(date(2001, 1, 1)),\n)\n</code></pre>"},{"location":"tutorial/#generating-versioned-schemas","title":"Generating versioned schemas","text":"<p>Now let's generate the only version of our schemas -- the one we created in the first step.  We'll need the our API versions and the package representing the latest versions of our schemas.</p> <pre><code># generate_schemas.py\nfrom data import latest\nfrom versions import version_bundle\nfrom cadwyn import generate_code_for_versioned_packages\n\ngenerate_code_for_versioned_packages(latest, version_bundle)\n</code></pre> <p>WARNING Cadwyn doesn't edit your imports when generating schemas so if you make any imports from versioned code to versioned code, I would suggest using relative imports to make sure that they will still work as expected after code generation.</p>"},{"location":"tutorial/#generating-versioned-routes","title":"Generating versioned routes","text":"<pre><code># routes.py\nfrom data.latest.users import UserCreateRequest, UserResource\nfrom versions import version_bundle\nfrom data import latest\nfrom cadwyn import VersionedAPIRouter, Cadwyn\nimport uuid\nimport uvicorn\n\ndatabase_parody = {}\nrouter = VersionedAPIRouter()\n\n\n@router.post(\"/users\", response_model=UserResource)\nasync def create_user(payload: UserCreateRequest):\n    id_ = uuid.uuid4()\n    database_parody[id_] = {\n        \"id\": id_,\n        \"address\": payload.address,\n    }\n    return database_parody[id_]\n\n\n@router.get(\"/users/{user_id}\", response_model=UserResource)\nasync def get_user(user_id: uuid.UUID):\n    return database_parody[user_id]\n\n\napp = Cadwyn(versions=version_bundle, latest_schemas_package=latest)\napp.generate_and_include_versioned_routers(router)\n\nuvicorn.run(app)\n</code></pre> <p>That's it! Our app is ready to run.</p> <p>Cadwyn has just generated a separate directory with the versioned schemas for us: one for each API version defined in our <code>VersionBundle</code>. If we run the app, we will see the following dashboard:</p> <p></p>"},{"location":"tutorial/#turning-address-into-a-list","title":"Turning address into a list","text":"<p>During our development, we have realized that the initial API design was wrong and that addresses should have always been a list because the user wants to have multiple addresses to choose from so now we have to change the type of the \"address\" field to the list of strings.</p> <pre><code># data/latest/users.py\nfrom pydantic import BaseModel, Field\nimport uuid\n\n\nclass BaseUser(BaseModel):\n    addresses: list[str] = Field(min_items=1)\n\n\nclass UserCreateRequest(BaseUser):\n    pass\n\n\nclass UserResource(BaseUser):\n    id: uuid.UUID\n</code></pre> <pre><code># routes.py\nfrom data.latest.users import UserCreateRequest, UserResource\nfrom versions import version_bundle\nfrom data import latest\nfrom cadwyn import VersionedAPIRouter, Cadwyn\nimport uuid\nimport uvicorn\n\ndatabase_parody = {}\nrouter = VersionedAPIRouter()\n\n\n@router.post(\"/users\", response_model=UserResource)\nasync def create_user(payload: UserCreateRequest):\n    id_ = uuid.uuid4()\n    database_parody[id_] = {\n        \"id\": id_,\n        \"addresses\": payload.addresses,\n    }\n    return database_parody[id_]\n\n\n@router.get(\"/users/{user_id}\", response_model=UserResource)\nasync def get_user(user_id: uuid.UUID):\n    return database_parody[user_id]\n\n\napp = Cadwyn(versions=version_bundle, latest_schemas_package=latest)\napp.generate_and_include_versioned_routers(router)\n\nuvicorn.run(app)\n</code></pre> <p>But every user of ours will now have their API integration broken. To prevent that, we have to introduce API versioning. There aren't many methods of doing that. Most of them force you to either duplicate your schemas, your endpoints, or your entire app instance. And it makes sense, really: duplication is the only way to make sure that you will not break old versions with your new versions; the bigger the piece you duplicating -- the safer. Of course, the safest being duplicating the entire app instance and even having a separate database. But that is expensive and makes it either impossible to make breaking changes often or to support many versions. As a result, either you need infinite resources, very long development cycles, or your users will need to often migrate from version to version.</p> <p>Stripe has come up with a solution: let's have one latest app version whose responses get migrated to older versions and let's describe changes between these versions using migrations. This approach allows them to keep versions for years without dropping them. Obviously, each breaking change is still bad and each version still makes our system more complex and expensive, but their approach gives us a chance to minimize that. Additionally, it allows us backport features and bugfixes to older versions. However, you will also be backporting bugs, which is a sad consequence of eliminating duplication.</p> <p>Cadwyn is heavily inspired by this approach so let's continue our tutorial and now try to combine the two versions we created using versioning.</p>"},{"location":"tutorial/#creating-the-migration","title":"Creating the Migration","text":"<p>We need to create a migration to handle changes between these versions. For every endpoint whose <code>response_model</code> is <code>UserResource</code>, this migration will convert the list of addresses back to a single address when migrating to the previous version. Yes, migrating back: you might be used to database migrations where we write upgrade migration and downgrade migration but here our goal is to have an app of latest version and to describe what older versions looked like in comparison to it. That way the old versions are frozen in migrations and you can almost safely forget about them.</p> <pre><code># versions/v2002_01_01.py\nfrom pydantic import Field\nfrom data.latest.users import BaseUser, UserCreateRequest, UserResource\nfrom cadwyn.structure import (\n    schema,\n    VersionChange,\n    convert_request_to_next_version_for,\n    convert_response_to_previous_version_for,\n    RequestInfo,\n    ResponseInfo,\n)\n\n\nclass ChangeAddressToList(VersionChange):\n    description = (\n        \"Change user address to a list of strings to \"\n        \"allow the user to specify multiple addresses\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        # We assume that issubclass(UserCreateRequest, BaseUser) and\n        #                issubclass(UserResource, BaseUser)\n        schema(BaseUser).field(\"addresses\").didnt_exist,\n        schema(BaseUser).field(\"address\").existed_as(type=str, info=Field()),\n    )\n\n    @convert_request_to_next_version_for(UserCreateRequest)\n    def change_address_to_multiple_items(request: RequestInfo):\n        request.body[\"addresses\"] = [request.body.pop(\"address\")]\n\n    @convert_response_to_previous_version_for(UserResource)\n    def change_addresses_to_single_item(response: ResponseInfo) -&gt; None:\n        response.body[\"address\"] = response.body.pop(\"addresses\")[0]\n</code></pre> <p>See how we are popping the first address from the list? This is only guaranteed to be possible because we specified earlier that <code>min_items</code> for <code>addresses</code> must be <code>1</code>. If we didn't, then the user would be able to create a user in a newer version that would be impossible to represent in the older version. I.e. If anyone tried to get that user from the older version, they would get a <code>ResponseValidationError</code> because the user wouldn't have data for a mandatory <code>address</code> field. You need to always keep in mind that API versioning is only for versioning your API, your interface. Your versions must still be completely compatible in terms of data. If they are not, then you are versioning your data and you should really go with a separate app instance. Otherwise, your users will have a hard time migrating back and forth between API versions and so many unexpected errors.</p> <p>See how we added a migration not only for response but also for request? This will allow our business logic to stay completely the same, no matter which version it was called from. Cadwyn will always give your business logic the request model from the latest version or from a custom schema if you want to.</p>"},{"location":"tutorial/#grouping-version-changes","title":"Grouping Version Changes","text":"<p>Finally, we group the version changes in the <code>VersionBundle</code> class.</p> <pre><code># versions/__init__.py\nfrom versions.v2002_01_01 import ChangeAddressToList\nfrom cadwyn.structure import Version, VersionBundle\nfrom datetime import date\n\n\nversion_bundle = VersionBundle(\n    Version(date(2002, 1, 1), ChangeAddressToList),\n    Version(date(2001, 1, 1)),\n)\n</code></pre> <p>Let's run code generation, run our app, and then take a look at the generated dashboard and openapi schemas:</p> <p> </p> <p>The endpoint above is from the <code>2001-01-01</code> version. As you see, our routes and business logic are for the latest version but our openapi has all information about all API versions which is the main goal of cadwyn: a large number of long-living API versions without placing any burden on your business logic.</p> <p>Obviously, this was just a simple example and cadwyn has a lot more features so if you're interested -- take a look at the reference and recipes sections.</p>"}]}